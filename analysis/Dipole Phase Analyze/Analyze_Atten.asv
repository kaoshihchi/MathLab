close all; clear;
    addpath(fullfile(fileparts(mfilename('fullpath')), '..', '..', 'theory'));
%% -------- Constants (SI) --------
global q_e m_e hbar
q_e  = 1.602176634e-19;      % C
m_e  = 9.1093837015e-31;     % kg
hbar = 1.054571817e-34;      % J*s
mu_0 = 4*pi*1e-7;            % H/m
c    = 2.99792458e8;         % m/s

%% -------- User parameters --------
pixel_um = 0.88;                       % µm
pixel_m  = pixel_um * 1e-6;
tau_fs   = 40;                         % fs
tau_s    = tau_fs * 1e-15;

E1_mJ = 8.3;      E1_J = E1_mJ * 1e-3; % input.tiff
E2_mJ = 7.9;    E2_J = E2_mJ * 1e-3; % output.tiff

q         = 45;                        % harmonic order
lambda_nm = 808;                       % nm
omega_d   = 2*pi*c/(lambda_nm*1e-9);
I_p_eV    = 15.7596;                   % eV (Ar)
I_p       = I_p_eV * q_e;              % J

%% -------- Load images once --------
bg  = im2double(imread('background.tiff'));
in1 = im2double(imread('input.tiff'));
in2 = im2double(imread('output_0.12psi.tiff'));

% Background subtraction (clip at 0)
corr1 = max(in1 - bg, 0);
corr2 = max(in2 - bg, 0);

%% -------- Peak intensity maps (W/cm^2) --------
% If you already have these helpers, keep them. Otherwise:
% [~, I_Wcm2] = ComputePeakIntensity(corr, pixel_m, E_J, tau_s);
[~, I1_Wcm2] = ComputePeakIntensity(corr1, pixel_m, E1_J, tau_s);
[~, I2_Wcm2] = ComputePeakIntensity(corr2, pixel_m, E2_J, tau_s);

% Display intensity maps
figure; tiledlayout(1,2,'Padding','compact','TileSpacing','compact');
nexttile; imagesc(I1_Wcm2); axis image; colormap hot; cb=colorbar;
cb.Label.String='Peak Intensity (W/cm^2)';
title(sprintf('input.tiff  (%.3f mJ)', E1_mJ)); xlabel('X pixel'); ylabel('Y pixel');

nexttile; imagesc(I2_Wcm2); axis image; colormap hot; cb=colorbar;
cb.Label.String='Peak Intensity (W/cm^2)';
title(sprintf('output.tiff (%.3f mJ)', E2_mJ)); xlabel('X pixel'); ylabel('Y pixel');

Ipk1 = max(I1_Wcm2(:)); Ipk2 = max(I2_Wcm2(:));
fprintf('Peak intensity (input.tiff,  %.3f mJ): %.3g W/cm^2\n', E1_mJ, Ipk1);
fprintf('Peak intensity (output.tiff, %.3f mJ): %.3g W/cm^2\n', E2_mJ, Ipk2);

%% -------- Choose centroid mode --------
% Options: 'weighted' or 'geometric'
centroid_mode = 'geometric';   % <- change to 'weighted' when desired

%% -------- Locate focal spot (single particle) with mode switch --------
function [center_xy, stats] = locateSpot(I, centroid_mode)
    % I: intensity map (double, nonnegative)
    I = double(I);
    if ~isfinite(max(I(:))) || max(I(:)) <= 0
        error('locateSpot: invalid intensity map');
    end

    % 1) Light smoothing to suppress noise; normalize
    I_s = imgaussfilt(I, 1.0);          % sigma ~ 1 pixel
    In  = I_s / max(I_s(:));            % [0,1]

    % 2) Threshold -> keep largest blob
    T  = graythresh(In);                 % Otsu
    BW = In > max(0.35, 0.8*T);          % robust for various contrasts
    BW = bwareafilt(BW, 1);

    % Fallback if thresholding found nothing
    if ~any(BW(:))
        warning('Thresholding found no blob; falling back to top 0.5%% pixels.');
        p  = prctile(In(:), 99.5);
        BW = In >= p;
        BW = bwareafilt(BW, 1);
    end

    % 3) Compute center based on mode
    switch lower(string(centroid_mode))
        case "weighted"
            % intensity-weighted centroid (sub-pixel)
            S = regionprops(BW, In, ...
                'WeightedCentroid','Centroid','Area','BoundingBox', ...
                'Orientation','MajorAxisLength','MinorAxisLength','PixelIdxList');
            if isempty(S)
                [yy, xx] = find(In == max(In(:)), 1, 'first');
                center_xy = [xx, yy];
                stats = struct('WeightedCentroid', center_xy, 'Centroid', center_xy, ...
                    'Area', 1, 'BoundingBox', [xx yy 1 1], ...
                    'Orientation', 0, 'MajorAxisLength', 0, 'MinorAxisLength', 0);
            else
                center_xy = S(1).WeightedCentroid;   % [x,y]
                stats     = S(1);
            end

        case "geometric"
            % pure geometry centroid of the binary mask
            S = regionprops(BW, ...
                'Centroid','Area','BoundingBox','Orientation', ...
                'MajorAxisLength','MinorAxisLength','PixelIdxList');
            if isempty(S)
                [yy, xx] = find(In == max(In(:)), 1, 'first');
                center_xy = [xx, yy];
                stats = struct('Centroid', center_xy, ...
                    'Area', 1, 'BoundingBox', [xx yy 1 1], ...
                    'Orientation', 0, 'MajorAxisLength', 0, 'MinorAxisLength', 0);
            else
                center_xy = S(1).Centroid;           % [x,y]
                stats     = S(1);
            end

        otherwise
            error('centroid_mode must be ''weighted'' or ''geometric''.');
    end

    % Also return the binary mask via stats for optional visualization
    stats.Mask = BW;
end
%% -------- Use it on your two intensity maps --------
[c1_xy, s1] = locateSpot(I1_Wcm2, centroid_mode);
[c2_xy, s2] = locateSpot(I2_Wcm2, centroid_mode);

x1_um = (c1_xy(1) - 1) * pixel_um;  y1_um = (c1_xy(2) - 1) * pixel_um;
x2_um = (c2_xy(1) - 1) * pixel_um;  y2_um = (c2_xy(2) - 1) * pixel_um;

% Re-plot with overlays
figure; tl = tiledlayout(1,2,'Padding','compact','TileSpacing','compact');

ax1 = nexttile; imagesc(I1_Wcm2); axis image; colormap(ax1, hot); cb=colorbar(ax1);
cb.Label.String='Peak Intensity (W/cm^2)';
title(ax1, sprintf('input.tiff  (%.3f mJ) — %s centroid', E1_mJ, centroid_mode));
xlabel(ax1,'X pixel'); ylabel(ax1,'Y pixel'); set(ax1,'YDir','normal');
drawCrossAt(ax1, c1_xy, 12, 1.8, 'w'); drawEllipse(ax1, s1, 'c', 1.4);

ax2 = nexttile; imagesc(I2_Wcm2); axis image; colormap(ax2, hot); cb=colorbar(ax2);
cb.Label.String='Peak Intensity (W/cm^2)';
title(ax2, sprintf('output.tiff (%.3f mJ) — %s centroid', E2_mJ, centroid_mode));
xlabel(ax2,'X pixel'); ylabel(ax2,'Y pixel'); set(ax2,'YDir','normal');
drawCrossAt(ax2, c2_xy, 12, 1.8, 'w'); drawEllipse(ax2, s2, 'c', 1.4);

sgtitle(tl, 'Peak Intensity Maps with Spot Centers (+ optional ellipse)');

fprintf('\n--- Spot centers (%s) ---\n', centroid_mode);
fprintf('input.tiff  center: (x=%.2f px, y=%.2f px)  -> (%.2f µm, %.2f µm)\n', ...
    c1_xy(1), c1_xy(2), x1_um, y1_um);
fprintf('output.tiff center: (x=%.2f px, y=%.2f px)  -> (%.2f µm, %.2f µm)\n\n', ...
    c2_xy(1), c2_xy(2), x2_um, y2_um);


%% -------- Simple cross & (optional) ellipse overlay helpers --------
function drawCrossAt(ax, center_xy, L, lw, color)
    if nargin < 4, lw = 1.6; end
    if nargin < 5, color = 'w'; end
    x = center_xy(1);  y = center_xy(2);
    hold(ax, 'on');
    line(ax, [x-L, x+L], [y, y], 'Color', color, 'LineWidth', lw);
    line(ax, [x, x], [y-L, y+L], 'Color', color, 'LineWidth', lw);
    plot(ax, x, y, '+', 'Color', color, 'MarkerSize', 10, 'LineWidth', lw);
end

function drawEllipse(ax, stats, color, lw)
    % Visualize fitted ellipse from regionprops (major/minor + orientation)
    if nargin < 3, color = 'c'; end
    if nargin < 4, lw = 1.2; end
    if ~isfield(stats,'MajorAxisLength') || stats.MajorAxisLength==0
        return;
    end
    a = stats.MajorAxisLength/2;
    b = stats.MinorAxisLength/2;
    th = deg2rad(-stats.Orientation); % regionprops angle: CCW from x-axis, display needs minus
    t = linspace(0, 2*pi, 200);
    R = [cos(th) -sin(th); sin(th) cos(th)];
    xy = R * [a*cos(t); b*sin(t)];
    x  = xy(1,:) + stats.Centroid(1);
    y  = xy(2,:) + stats.Centroid(2);
    hold(ax,'on'); plot(ax, x, y, '-', 'Color', color, 'LineWidth', lw);
end
